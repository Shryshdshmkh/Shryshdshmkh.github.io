    body {
        font-family: 'Georgia', serif;
        line-height: 1.6;
        color: #333;
        background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);
        min-height: 100vh;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    .blog-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        margin: 20px 0;
        transition: transform 0.3s ease;
    }

    .blog-card:hover {
        transform: translateY(-5px);
    }

    .header {
        background: linear-gradient(135deg, #6c5ce7 0%, #8e44ad 100%);
        color: white;
        padding: 50px 40px;
        text-align: center;
        position: relative;
        overflow: hidden;
    }

    .header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
        animation: flow 8s linear infinite;
    }

    @keyframes flow {
        0% { transform: translateX(-100%) rotate(0deg); }
        100% { transform: translateX(100%) rotate(360deg); }
    }

    .header h1 {
        font-size: 3em;
        margin-bottom: 15px;
        position: relative;
        z-index: 1;
    }

    .header p {
        font-size: 1.3em;
        opacity: 0.9;
        position: relative;
        z-index: 1;
    }

    .content {
        padding: 40px;
    }

    .section {
        margin-bottom: 45px;
    }

    .section h2 {
        color: #6c5ce7;
        font-size: 2.3em;
        margin-bottom: 25px;
        border-bottom: 3px solid #a29bfe;
        padding-bottom: 10px;
        position: relative;
    }

    .section h3 {
        color: #8e44ad;
        font-size: 1.7em;
        margin: 30px 0 15px 0;
    }

    .section p {
        margin-bottom: 15px;
        text-align: justify;
        font-size: 1.1em;
    }

    .math-formula {
        background: linear-gradient(135deg, #f1f2f6 0%, #dfe6e9 100%);
        border: 2px solid #a29bfe;
        border-radius: 15px;
        padding: 30px;
        margin: 30px 0;
        font-family: 'Courier New', monospace;
        font-size: 1.2em;
        text-align: center;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    .example-box {
        background: linear-gradient(135deg, #00cec9 0%, #55efc4 100%);
        color: #2d3436;
        padding: 35px;
        border-radius: 15px;
        margin: 30px 0;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
    }

    .example-box h4 {
        font-size: 1.5em;
        margin-bottom: 20px;
        color: #004d40;
    }

    .network-diagram {
        background: white;
        border: 3px solid #6c5ce7;
        border-radius: 20px;
        padding: 40px;
        margin: 30px 0;
        text-align: center;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
    }
    
    .bipartite-graph {
        display: flex;
        justify-content: space-around;
        align-items: center;
        position: relative;
        height: 200px;
    }
    
    .bipartite-graph .node-set {
        display: flex;
        flex-direction: column;
        gap: 20px;
        z-index: 2;
    }

    .node {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        color: white;
        font-weight: bold;
        font-size: 1.3em;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
    }
    
    .node:hover {
        transform: scale(1.1);
    }
    
    .node-set1 { background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%); }
    .node-set2 { background: linear-gradient(135deg, #fd79a8 0%, #e84393 100%); }
    
    .bipartite-graph svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }
    
    .bipartite-graph svg line {
        stroke: #a29bfe;
        stroke-width: 2;
        stroke-dasharray: 5,5;
    }
    
    .cost-matrix {
        width: 80%;
        margin: 20px auto;
        border-collapse: collapse;
        text-align: center;
    }
    
    .cost-matrix th, .cost-matrix td {
        border: 2px solid #004d40;
        padding: 12px;
    }

    .cost-matrix th {
        background-color: #00796b;
        color: white;
    }
    
    .optimal { background-color: #a7ffeb !important; font-weight: bold; }

    .algorithm-box {
        background: linear-gradient(135deg, #e84393 0%, #d63031 100%);
        color: white;
        padding: 30px;
        border-radius: 15px;
        margin: 25px 0;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    }

    .algorithm-box h4 {
        font-size: 1.4em;
        margin-bottom: 15px;
        color: #fff;
    }

    .applications {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 25px;
        margin: 30px 0;
    }

    .app-card {
        background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        transition: all 0.3s ease;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    .app-card:hover {
        transform: translateY(-8px) scale(1.03);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    }

    .app-card h4 {
        font-size: 1.4em;
        margin-bottom: 15px;
        color: #fff;
    }
    
    .highlight {
        background: linear-gradient(120deg, #6c5ce7 0%, #a29bfe 100%);
        padding: 4px 10px;
        border-radius: 6px;
        font-weight: bold;
        color: white;
    }

    @media (max-width: 768px) {
        .header h1 { font-size: 2.5em; }
        .section h2 { font-size: 2em; }
        .content { padding: 25px; }
        .bipartite-graph { height: auto; flex-direction: column; gap: 40px; }
        .bipartite-graph svg { display: none; }
    }
</style>


        <div class="content">
            <div class="section">
                <h2>The Quest for Optimal Pairing</h2>
                <p>In a world driven by efficiency, matching the right resources to the right tasks is a universal challenge. How do you assign employees to projects to maximize productivity? Or pair delivery drivers to routes to minimize fuel costs? These scenarios are all instances of a classic optimization puzzle: the <span class="highlight">Assignment Problem</span>.</p>
                
                <p>The problem is beautifully simple in its goal: given two equally sized groups of items, we want to create one-to-one pairings between them in a way that minimizes the total cost of all pairings. It's about finding the "perfect match" not just for one pair, but for the entire system simultaneously.</p>
            </div>

            <div class="section">
                <h2>Anatomy of the Assignment Problem</h2>
                <p>At its core, the assignment problem involves three key components:</p>
                <div class="network-diagram">
                    <h4>Bipartite Matching with Costs</h4>
                    <div class="bipartite-graph">
                        <svg>
                            <!-- Lines representing potential assignments -->
                            <line x1="15%" y1="20%" x2="85%" y2="20%" />
                            <line x1="15%" y1="20%" x2="85%" y2="50%" />
                            <line x1="15%" y1="50%" x2="85%" y2="20%" />
                            <line x1="15%" y1="50%" x2="85%" y2="80%" />
                            <line x1="15%" y1="80%" x2="85%" y2="50%" />
                            <line x1="15%" y1="80%" x2="85%" y2="80%" />
                        </svg>
                        <div class="node-set">
                            <div class="node node-set1">A</div>
                            <div class="node node-set1">B</div>
                            <div class="node node-set1">C</div>
                        </div>
                        <div class="node-set">
                            <div class="node node-set2">X</div>
                            <div class="node node-set2">Y</div>
                            <div class="node node-set2">Z</div>
                        </div>
                    </div>
                     <p style="margin-top: 20px; color: #666;">Matching each item from Set 1 (e.g., Workers) to exactly one item in Set 2 (e.g., Jobs).</p>
                </div>

                <ol>
                    <li><strong>Two Equal Sets (N₁ and N₂):</strong> These are the groups of items to be matched. For example, a set of swimmers and a set of swimming events.</li>
                    <li><strong>Possible Assignments (A):</strong> A collection of all valid pairs between the two sets. For instance, not every swimmer can compete in every event.</li>
                    <li><strong>Assignment Costs (cᵢⱼ):</strong> A cost associated with each possible assignment. This could be the time it takes a machine to complete a job, or the preference score a medical student has for a particular hospital internship.</li>
                </ol>
            </div>
            
            <div class="section">
                <h2>Connection to Minimum Cost Flow</h2>
                <p>One of the most elegant aspects of the assignment problem is that it's a special, highly structured case of the <span class="highlight">Minimum Cost Flow</span> problem. This connection allows us to use powerful network flow algorithms to find the solution. The transformation is straightforward:</p>
                
                <div class="math-formula">
                    <strong>1. Define the Network:</strong><br>
                    Construct a network G = (N₁ ∪ N₂, A) where N₁ are source nodes and N₂ are destination nodes.
                </div>
                
                <div class="math-formula">
                    <strong>2. Set Supplies and Demands:</strong><br>
                    • For each source node i ∈ N₁, set supply b(i) = 1.<br>
                    • For each destination node j ∈ N₂, set demand b(j) = -1.
                </div>
                
                <div class="math-formula">
                    <strong>3. Set Arc Capacities:</strong><br>
                    • For every possible assignment arc (i, j) ∈ A, set capacity uᵢⱼ = 1.
                </div>
                
                <p>This setup perfectly models the problem. Each source node (e.g., a worker) has exactly one unit of "supply" to give. Each destination node (e.g., a job) has a "demand" for exactly one unit. The capacity of 1 on each arc ensures that a worker can only be assigned to one job. Solving for the minimum cost flow in this network yields the minimum cost assignment.</p>
            </div>

            <div class="section">
                <h2>Real-World Example: Assigning Consultants to Projects</h2>
                <div class="example-box">
                    <h4>Scenario: Optimizing a Consulting Team</h4>
                    <p>A manager has three consultants (Ana, Ben, Chloe) and three projects (Phoenix, Quest, Titan). The table below shows the estimated cost (in hours) for each consultant to complete each project based on their skills.</p>

                    <table class="cost-matrix">
                        <thead>
                            <tr><th></th><th>Project Phoenix</th><th>Project Quest</th><th>Project Titan</th></tr>
                        </thead>
                        <tbody>
                            <tr><th>Ana</th><td>10</td><td>15</td><td>9</td></tr>
                            <tr><th>Ben</th><td>9</td><td>18</td><td>5</td></tr>
                            <tr><th>Chloe</th><td>6</td><td>14</td><td>3</td></tr>
                        </tbody>
                    </table>
                    
                    <p><strong>The Goal:</strong> Assign each consultant to exactly one project to minimize the total hours worked.</p>
                    
                    <h4>Optimal Solution:</h4>
                    <p>After solving the assignment problem (e.g., using the Hungarian algorithm), we find the perfect match:</p>
                    
                    <table class="cost-matrix">
                        <thead>
                            <tr><th></th><th>Project Phoenix</th><th>Project Quest</th><th>Project Titan</th></tr>
                        </thead>
                        <tbody>
                            <tr><th>Ana</th><td class="optimal">10</td><td>15</td><td>9</td></tr>
                            <tr><th>Ben</th><td>9</td><td>18</td><td class="optimal">5</td></tr>
                            <tr><th>Chloe</th><td>6</td><td class="optimal">14</td><td>3</td></tr>
                        </tbody>
                    </table>
                    
                    <p>The optimal assignment is:</p>
                    <ul>
                        <li><strong>Ana → Project Phoenix (10 hours)</strong></li>
                        <li><strong>Ben → Project Titan (5 hours)</strong></li>
                        <li><strong>Chloe → Project Quest (14 hours)</strong></li>
                    </ul>
                    <p><strong>Total Minimum Cost:</strong> 10 + 5 + 14 = <strong>29 hours</strong>. Any other combination would result in a higher total cost.</p>
                </div>
            </div>

            <div class="section">
                <h2>Solving the Puzzle: The Hungarian Algorithm</h2>
                <div class="algorithm-box">
                    <h4>The Hungarian Algorithm</h4>
                    <p>While the assignment problem can be solved as a minimum cost flow problem, its unique structure allows for a much more efficient, specialized algorithm known as the <strong>Hungarian Method</strong>.</p>
                    <p>Developed by Harold Kuhn in 1955, this algorithm works by manipulating the cost matrix through a series of row and column reductions to find an assignment with zero cost in the modified matrix, which corresponds to the optimal assignment in the original matrix. It is significantly faster for this specific problem than general-purpose linear programming solvers.</p>
                </div>
            </div>

            <div class="section">
                <h2>Widespread Applications</h2>
                <p>The assignment problem appears in countless real-world scenarios:</p>
                <div class="applications">
                    <div class="app-card"><h4>👥 Human Resources</h4><p>Assigning employees to jobs, shifts, or training programs.</p></div>
                    <div class="app-card"><h4>🤖 Robotics</h4><p>Assigning tasks to a swarm of robots in a warehouse.</p></div>
                    <div class="app-card"><h4>🚚 Logistics</h4><p>Assigning delivery trucks to a set of routes or packages.</p></div>
                    <div class="app-card"><h4>🎓 Education</h4><p>Assigning students to dorm rooms or projects.</p></div>
                    <div class="app-card"><h4>🚕 Ride-Sharing</h4><p>Matching available drivers to nearby passengers.</p></div>
                    <div class="app-card"><h4>🏥 Healthcare</h4><p>Pairing medical school graduates with available hospital residencies.</p></div>
                </div>
            </div>

            <div class="section">
                <h2>Conclusion</h2>
                <p>The Assignment Problem is a testament to the power of optimization. It's a fundamental model that elegantly captures the essence of one-to-one resource allocation. Its close relationship with network flow theory not only provides a deep theoretical understanding but also equips us with the tools to solve a wide array of practical challenges, ensuring that in a world of limited resources, we can always find the most efficient and perfect match.</p>
            </div>
        </div>
    </div>
</div>
